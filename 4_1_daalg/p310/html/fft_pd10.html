<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fft_pd10 API documentation</title>
<meta name="description" content="Module with the implementation of:
- Mini-Project 3: FFT and Multiplication of Polynomials and Numbers.
Dynamic Programming." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fft_pd10</code></h1>
</header>
<section id="section-intro">
<p>Module with the implementation of:
- Mini-Project 3: FFT and Multiplication of Polynomials and Numbers.
Dynamic Programming.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module with the implementation of:
    - Mini-Project 3: FFT and Multiplication of Polynomials and Numbers.
    Dynamic Programming.
&#34;&#34;&#34;
__author__ = &#39;Daniel Mohedano &amp; Silvia Sope√±a&#39;

import numpy as np
from typing import List, Dict, Tuple, Callable
import random
import time
from itertools import combinations_with_replacement


def _extend_table(t: np.ndarray, length: int = -1) -&gt; np.ndarray:
    &#34;&#34;&#34;Extends a table to the smallest power of 2 greater than the number of
    elements in t.

    Args:
        t (np.ndarray): Table.
        length (int): Desired length.

    Returns:
        np.ndarray: The extended table.
    &#34;&#34;&#34;
    if length != -1:
        a = int(np.ceil(np.log2(length)))
    else:
        a = int(np.ceil(np.log2(len(t))))

    if 2 ** a == len(t):
        return t
    else:
        return np.concatenate((t, [0]*((2 ** a) - len(t))))


def _gen_point(j: int, N: int) -&gt; complex:
    &#34;&#34;&#34;Generates the complex value for the point j out of N points.

    Args:
        j (int): Point&#39;s index.
        N (int): Total of points.

    Returns:
        (complex): Point.
    &#34;&#34;&#34;
    return np.exp(2 * np.pi * 1j * j / N)


def _degree(pol: List[int]) -&gt; int:
    &#34;&#34;&#34;Degree of a polynomial.

    Args:
        pol (list): List of coefficients of the polynomial.

    Returns:
        int: Degree.
    &#34;&#34;&#34;
    deg = 0
    for i in range(len(pol)):
        if pol[i] != 0:
            deg = i

    return deg


def fft(t: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculates the FFT of table t.

    Args:
        t (np.ndarray): Table.

    Returns:
        np.ndarray: Result of FFT.
    &#34;&#34;&#34;
    if len(t) == 1:
        return t

    t = _extend_table(t)
    N = len(t)

    t_even = np.array([t[2 * i] for i in range(N // 2)])
    t_odd = np.array([t[2 * i + 1] for i in range(N // 2)])

    f_even = fft(t_even)
    f_odd = fft(t_odd)

    result = [None] * N

    for j in range(N):
        result[j] = f_even[j % (N // 2)] + _gen_point(j, N)*f_odd[j % (N // 2)]

    return np.array(result)


def invert_fft(
        t: np.ndarray,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculates the inverse FFT with the provided function.

    Args:
        t (np.ndarray): Table.
        fft_func (func): Implementation of FFT.

    Returns:
        np.ndarray: Result of the inverse FFT.
    &#34;&#34;&#34;
    t = _extend_table(t)
    N = len(t)

    # 1. Conjugate
    t = np.array([np.conj(x) for x in t])

    # 2. Apply FFT
    result = fft_func(t)

    # 3&amp;4. Conjugate again and divide by 2 ** k = N
    result = np.array([np.conj(x) / N for x in result])

    return result


def rand_polynomial(long: int = 2**10, base: int = 10) -&gt; List[int]:
    &#34;&#34;&#34;Generates a list with the coefficients of the polynomial with degree
    length - 1.

    Args:
        long (int): Length of the list. long - 1 identifies the degree of the
        polynomial.
        base (int): Base of the coefficients.

    Returns:
        list: List with the coefficients of the polynomial.
    &#34;&#34;&#34;
    return [random.randint(0, base - 1) for i in range(long - 1)] + \
        [random.randint(1, base - 1)]


def poli_2_num(l_pol: List[int], base: int = 10) -&gt; int:
    &#34;&#34;&#34;Evaluates the polynomial with a certain base using Horner&#39;s rule.

    Args:
        l_pol (list): List of polynomial&#39;s coefficients.
        base (int): Base of the polynomial.

    Returns:
        int: Evaluation on the base.
    &#34;&#34;&#34;
    x = l_pol[-1]

    for i in range(len(l_pol) - 2, -1, -1):
        x = x * base + l_pol[i]

    return x


def rand_number(num_digits: int, base: int = 10) -&gt; int:
    &#34;&#34;&#34;Generates a random int with num_digits figures in the base provided.

    Args:
        num_digits (int): Number of digits.
        base (int): Base of the number.

    Returns:
        int: The random number.
    &#34;&#34;&#34;
    return poli_2_num(rand_polynomial(num_digits, base), base)


def num_2_poli(num: int, base: int = 10) -&gt; List[int]:
    &#34;&#34;&#34;Converts a number into its polynomial representation in the base given.

    Args:
        num (int): Number to convert.
        base (int): Base of the polynomial.

    Returns:
        list: The polynomial.
    &#34;&#34;&#34;
    pol = []

    while num != 0:
        pol.append(num % base)
        num = num // base

    return pol


def mult_polynomials_fft(
        l_pol_1: List[int], l_pol_2: List[int],
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[int]:
    &#34;&#34;&#34;Multiplies two polynomials applying the FFT algorithm.

    Args:
        l_pol_1 (list): List of coefficients of polynomial 1.
        l_pol_2 (list): List of coefficients of polynomial 2.
        fft_func (function): Function of FFT.

    Returns:
        list: Coefficients resulting of the multiplication.
    &#34;&#34;&#34;
    length1 = _degree(l_pol_1)
    length2 = _degree(l_pol_2)

    pol_1 = _extend_table(np.array(l_pol_1), length1 + length2 + 1)
    pol_2 = _extend_table(np.array(l_pol_2), length1 + length2 + 1)

    # 1. Compute values of polynomials in special points (FFT)
    fft1 = fft_func(pol_1)
    fft2 = fft_func(pol_2)

    # 2. PQ(Xi) = P(Xi)Q(Xi)
    mult_points = np.array([fft1[i] * fft2[i] for i in range(len(pol_1))])

    # 3. Inverse FFT
    mult_coeff = invert_fft(np.array(mult_points), fft_func)

    return [round(x) for x in mult_coeff.real]


def mult_numbers_fft(
        num1: int, num2: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; int:
    &#34;&#34;&#34;Multiplies integers using the FFT.

    Args:
        num1 (int): The first integer.
        num2 (int): The second integer.
        fft_func (function): The FFT function.

    Returns:
        int: The result of the multiplication.
    &#34;&#34;&#34;
    pol1 = num_2_poli(num1)
    pol2 = num_2_poli(num2)

    result = mult_polynomials_fft(pol1, pol2, fft_func)

    return poli_2_num(result)


def time_fft(
        n_tables: int, num_coefs_ini: int, num_coefs_fin: int, step: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[float]:
    &#34;&#34;&#34;Times the execution of the FFT implementation provided.

    Args:
        n_tables (int): Number of tables to generate.
        num_coefs_ini (int): Initial number of coefficients.
        num_coefs_fin (int): Final number of coefficients.
        step (int): Step for the number of coefficients.
        fft_func (function): FFT implementation.

    Returns:
        list: List with the average times of the FFT.
    &#34;&#34;&#34;
    results = []
    n_coeffs = num_coefs_ini
    while n_coeffs &lt;= num_coefs_fin:
        total_time = 0.0

        for i in range(n_tables):
            pol = rand_polynomial(n_coeffs)

            t = time.time()
            fft_func(np.array(pol))
            t = time.time() - t

            total_time += t

        results.append(total_time / n_tables)
        n_coeffs += step

    return results


def time_mult_polynomials_fft(
        n_pairs: int, num_coefs_ini: int, num_coefs_fin: int, step: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[float]:
    &#34;&#34;&#34;Times the execution of multiplication of polynomials.

    Args:
        n_pairs (int): Number of pairs generated.
        num_coefs_ini (int): Initial number of coefficients.
        num_coefs_fin (int): Final number of coefficients.
        step (int): Step for the number of coefficients.
        fft_func (function): FFT implementation.

    Returns:
        list: List with the average times of the multiplication.
    &#34;&#34;&#34;
    results = []
    n_coeffs = num_coefs_ini
    while n_coeffs &lt;= num_coefs_fin:
        total_time = 0.0

        for i in range(n_pairs):
            pol1 = rand_polynomial(n_coeffs)
            pol2 = rand_polynomial(n_coeffs)

            t = time.time()
            mult_polynomials_fft(pol1, pol2, fft_func)
            t = time.time() - t

            total_time += t

        results.append(total_time / n_pairs)
        n_coeffs += step

    return results


def time_mult_numbers_fft(
        n_integers: int, num_digits_ini: int,
        num_digits_fin: int, step: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[float]:
    &#34;&#34;&#34;Times the execution of multiplication of numbers.

    Args:
        n_integers (int): Number of integers generated.
        num_digits_ini (int): Initial number of digits.
        num_digits_fin (int): Final number of digits.
        step (int): Step for the number of digits.
        fft_func (function): FFT implementation.

    Returns:
        list: List with the average times of the multiplication.
    &#34;&#34;&#34;
    results = []
    n_digits = num_digits_ini
    while n_digits &lt;= num_digits_fin:
        total_time = 0.0

        for i in range(n_integers):
            num1 = rand_number(n_digits)
            num2 = rand_number(n_digits)

            t = time.time()
            mult_numbers_fft(num1, num2, fft_func)
            t = time.time() - t

            total_time += t

        results.append(total_time / n_integers)
        n_digits += step

    return results


def min_coin_number(c: int, l_coins: List[int]) -&gt; int:
    &#34;&#34;&#34;Calculates the minimum number of l_coins coins needed to give c change.

    Args:
        c (int): Desired change.
        l_coins (list): Type of coins (values).

    Returns:
        int: Minimum number of coins needed.
    &#34;&#34;&#34;
    coins = sorted(l_coins)
    ci = {i: coins[i] for i in range(len(coins))}
    dp_matrix = np.zeros([len(coins), c + 1])

    # TODO: ask if 1 always a coin
    # Initilize first row of matrix: n(1,c) = c
    for i in range(dp_matrix.shape[1]):
        dp_matrix[0][i] = i

    # Dynamic loop: n(i,c) = min{n(i-1,c), 1+n(i,c-vi)}
    for i in range(1, dp_matrix.shape[0]):
        for j in range(1, dp_matrix.shape[1]):
            no_i = dp_matrix[i-1][j]
            yes_i = np.inf

            if j &gt;= ci[i]:
                yes_i = 1 + dp_matrix[i][j - ci[i]]

            dp_matrix[i][j] = min(no_i, yes_i)

    return int(dp_matrix[-1][-1])


def optimal_change(c: int, l_coins: List[int]) -&gt; Dict[int, int]:
    &#34;&#34;&#34;Returns a dict with the coins needed to give change c.

    Args:
        c (int): Desired change.
        l_coins (list): Coin values.

    Returns:
        dict: Amount of coins needed of each type to return change c.
    &#34;&#34;&#34;
    n_coins = min_coin_number(c, l_coins)

    for x in combinations_with_replacement(l_coins, n_coins):
        if sum(x) == c:
            return {coin: x.count(coin) for coin in l_coins}

    return {}


def bellman_ford(u: int, mg: np.ndarray) -&gt; Tuple[Dict[int, float],
                                                  Dict[int, int]]:
    &#34;&#34;&#34;Applies Bellman-Ford&#39;s algorithm to graph mg starting at node u.

    Args:
        u (int): Starting node.
        mg (np.ndarray): Adjacency matrix of the graph.

    Returns:
        dict: Minimum distances between u and every other node.
        dict: Previous node dictionary.
    &#34;&#34;&#34;
    d = {k: mg[u, k] for k in range(mg.shape[0])}
    p = {node: -1 for node in range(mg.shape[0])}
    p[u] = u

    for k in range(1, mg.shape[0]):
        for i in range(mg.shape[0]):
            if i == u:
                continue
            for j in range(mg.shape[0]):
                new_cost = d[j] + mg[j, i]
                if d[i] &gt; new_cost:
                    d[i] = new_cost
                    p[i] = j

    return d, p


def max_length_common_subsequence(str_1: str, str_2: str) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculates the array of partial common subsequence lengths.

    Args:
        str_1 (str): String 1.
        str_2 (str): String 2.

    Returns:
        np.ndarray: Array of partial common subsequence lengths.
    &#34;&#34;&#34;
    dp_matrix = np.zeros([len(str_2) + 1, len(str_1) + 1])

    for i in range(1, dp_matrix.shape[0]):
        for j in range(1, dp_matrix.shape[1]):
            if str_2[i - 1] == str_1[j - 1]:
                dp_matrix[i][j] = 1 + dp_matrix[i - 1][j - 1]
            else:
                dp_matrix[i][j] = max(dp_matrix[i][j - 1], dp_matrix[i - 1][j])

    return dp_matrix


def find_max_common_subsequence(str_1: str, str_2: str) -&gt; str:
    &#34;&#34;&#34;Calculates a possible common subsequence of maximum length.

    Args:
        str_1 (str): String 1.
        str_2 (str): String 2.

    Returns:
        str: Possible common subsequence of maximum length.
    &#34;&#34;&#34;
    matrix = max_length_common_subsequence(str_1, str_2)
    string = &#39;&#39;

    i, j = matrix.shape[0] - 1, matrix.shape[1] - 1

    while matrix[i][j] != 0:
        if matrix[i][j] == matrix[i - 1][j]:
            i -= 1
        elif matrix[i][j] == matrix[i][j - 1]:
            j -= 1
        else:
            string = str_1[j - 1] + string
            i -= 1
            j -= 1

    return string


def optimal_order(l_probs: List[float]) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Calculates the optimal search binary tree.

    Args:
        l_probs (list): List of probabilities of each key.

    Returns:
        np.ndarray: Matrix with optimal search costs.
        np.ndarray: Subtree roots.
    &#34;&#34;&#34;
    N = len(l_probs)
    dp_matrix = np.zeros([N, N])
    roots = np.ones([N, N], dtype=int)*-1

    for L in range(N-1, -1, -1):
        for R in range(L, N):
            sum_pi = sum(l_probs[L:R+1])

            if L != R:
                min_cj = np.inf
                for j in range(L, R + 1):
                    c_L, c_R = 0, 0
                    if j - 1 &gt;= L:
                        c_L = dp_matrix[L][j-1]
                    if j + 1 &lt;= R:
                        c_R = dp_matrix[j+1][R]

                    if c_L + c_R &lt; min_cj:
                        min_cj = c_L + c_R
                        roots[L][R] = j
            else:
                min_cj = 0

            dp_matrix[L][R] = sum_pi + min_cj

    return dp_matrix, roots


def _recursive_ordering(m_roots: np.ndarray, left: int, right: int,
                        ordering: List[int]):
    &#34;&#34;&#34; Recursive function for the ordering of the roots

    Args:
        m_roots (np.ndarray): Matrix of roots.
        l (int): Left index.
        r (int): Right index.
        ordering (list): Ordering of the roots
    &#34;&#34;&#34;
    # Base case
    if left == right:
        ordering.append(left)
        return

    # Find root of tree lr
    root = m_roots[left][right]
    ordering.append(root)
    if left &lt;= root - 1:
        _recursive_ordering(m_roots, left, root - 1, ordering)
    if root + 1 &lt;= right:
        _recursive_ordering(m_roots, root + 1, right, ordering)

    return


def list_opt_ordering_search_tree(m_roots: np.ndarray,
                                  l: int, r: int) -&gt; List[int]:
    &#34;&#34;&#34;Calculates the insertion order of the keys corresponding to the optimal
    binary search tree.

    Args:
        m_roots (np.ndarray): Matrix of roots.
        l (int): Left index.
        r (int): Right index.

    Returns:
        list: Insertion order of the keys.
    &#34;&#34;&#34;
    ordering: List[int] = []

    _recursive_ordering(m_roots, l, r, ordering)

    return ordering


if __name__ == &#39;__main__&#39;:
    original = np.array([1, 2, 1])
    result = fft(original)
    inv_result = invert_fft(result, fft)

    print(&#34;Original: &#34;, original)
    print(&#34;FFT: &#34;, result)
    print(&#34;Inverse FFT: &#34;, inv_result)

    x1 = 123456789
    x2 = 123456789

    print(mult_numbers_fft(x1, x2))
    print(x1 * x2)

    c = 7
    l_coins = [1, 3, 4, 5]
    print(min_coin_number(c, l_coins))
    print(optimal_change(c, l_coins))

    str_1 = &#39;forraje&#39;
    str_2 = &#39;zarzajo&#39;

    print(max_length_common_subsequence(str_1, str_2))
    print(find_max_common_subsequence(str_1, str_2))

    l_probs = [0.22, 0.18, 0.20, 0.05, 0.25, 0.02, 0.08]
    optimal_bst, roots = optimal_order(l_probs)
    print(optimal_bst)
    print(roots)
    print(list_opt_ordering_search_tree(roots, 0, 6))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fft_pd10.bellman_ford"><code class="name flex">
<span>def <span class="ident">bellman_ford</span></span>(<span>u:¬†int, mg:¬†numpy.ndarray) ‚Äë>¬†Tuple[Dict[int,¬†float],¬†Dict[int,¬†int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies Bellman-Ford's algorithm to graph mg starting at node u.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>int</code></dt>
<dd>Starting node.</dd>
<dt><strong><code>mg</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Adjacency matrix of the graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Minimum distances between u and every other node.</dd>
<dt><code>dict</code></dt>
<dd>Previous node dictionary.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bellman_ford(u: int, mg: np.ndarray) -&gt; Tuple[Dict[int, float],
                                                  Dict[int, int]]:
    &#34;&#34;&#34;Applies Bellman-Ford&#39;s algorithm to graph mg starting at node u.

    Args:
        u (int): Starting node.
        mg (np.ndarray): Adjacency matrix of the graph.

    Returns:
        dict: Minimum distances between u and every other node.
        dict: Previous node dictionary.
    &#34;&#34;&#34;
    d = {k: mg[u, k] for k in range(mg.shape[0])}
    p = {node: -1 for node in range(mg.shape[0])}
    p[u] = u

    for k in range(1, mg.shape[0]):
        for i in range(mg.shape[0]):
            if i == u:
                continue
            for j in range(mg.shape[0]):
                new_cost = d[j] + mg[j, i]
                if d[i] &gt; new_cost:
                    d[i] = new_cost
                    p[i] = j

    return d, p</code></pre>
</details>
</dd>
<dt id="fft_pd10.fft"><code class="name flex">
<span>def <span class="ident">fft</span></span>(<span>t:¬†numpy.ndarray) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the FFT of table t.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Table.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Result of FFT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fft(t: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculates the FFT of table t.

    Args:
        t (np.ndarray): Table.

    Returns:
        np.ndarray: Result of FFT.
    &#34;&#34;&#34;
    if len(t) == 1:
        return t

    t = _extend_table(t)
    N = len(t)

    t_even = np.array([t[2 * i] for i in range(N // 2)])
    t_odd = np.array([t[2 * i + 1] for i in range(N // 2)])

    f_even = fft(t_even)
    f_odd = fft(t_odd)

    result = [None] * N

    for j in range(N):
        result[j] = f_even[j % (N // 2)] + _gen_point(j, N)*f_odd[j % (N // 2)]

    return np.array(result)</code></pre>
</details>
</dd>
<dt id="fft_pd10.find_max_common_subsequence"><code class="name flex">
<span>def <span class="ident">find_max_common_subsequence</span></span>(<span>str_1:¬†str, str_2:¬†str) ‚Äë>¬†str</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates a possible common subsequence of maximum length.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>str_1</code></strong> :&ensp;<code>str</code></dt>
<dd>String 1.</dd>
<dt><strong><code>str_2</code></strong> :&ensp;<code>str</code></dt>
<dd>String 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Possible common subsequence of maximum length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_max_common_subsequence(str_1: str, str_2: str) -&gt; str:
    &#34;&#34;&#34;Calculates a possible common subsequence of maximum length.

    Args:
        str_1 (str): String 1.
        str_2 (str): String 2.

    Returns:
        str: Possible common subsequence of maximum length.
    &#34;&#34;&#34;
    matrix = max_length_common_subsequence(str_1, str_2)
    string = &#39;&#39;

    i, j = matrix.shape[0] - 1, matrix.shape[1] - 1

    while matrix[i][j] != 0:
        if matrix[i][j] == matrix[i - 1][j]:
            i -= 1
        elif matrix[i][j] == matrix[i][j - 1]:
            j -= 1
        else:
            string = str_1[j - 1] + string
            i -= 1
            j -= 1

    return string</code></pre>
</details>
</dd>
<dt id="fft_pd10.invert_fft"><code class="name flex">
<span>def <span class="ident">invert_fft</span></span>(<span>t:¬†numpy.ndarray, fft_func:¬†Callable[[numpy.ndarray],¬†numpy.ndarray]¬†=¬†&lt;function fft&gt;) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the inverse FFT with the provided function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Table.</dd>
<dt><strong><code>fft_func</code></strong> :&ensp;<code>func</code></dt>
<dd>Implementation of FFT.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Result of the inverse FFT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert_fft(
        t: np.ndarray,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculates the inverse FFT with the provided function.

    Args:
        t (np.ndarray): Table.
        fft_func (func): Implementation of FFT.

    Returns:
        np.ndarray: Result of the inverse FFT.
    &#34;&#34;&#34;
    t = _extend_table(t)
    N = len(t)

    # 1. Conjugate
    t = np.array([np.conj(x) for x in t])

    # 2. Apply FFT
    result = fft_func(t)

    # 3&amp;4. Conjugate again and divide by 2 ** k = N
    result = np.array([np.conj(x) / N for x in result])

    return result</code></pre>
</details>
</dd>
<dt id="fft_pd10.list_opt_ordering_search_tree"><code class="name flex">
<span>def <span class="ident">list_opt_ordering_search_tree</span></span>(<span>m_roots:¬†numpy.ndarray, l:¬†int, r:¬†int) ‚Äë>¬†List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the insertion order of the keys corresponding to the optimal
binary search tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>m_roots</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Matrix of roots.</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>int</code></dt>
<dd>Left index.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>Right index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Insertion order of the keys.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_opt_ordering_search_tree(m_roots: np.ndarray,
                                  l: int, r: int) -&gt; List[int]:
    &#34;&#34;&#34;Calculates the insertion order of the keys corresponding to the optimal
    binary search tree.

    Args:
        m_roots (np.ndarray): Matrix of roots.
        l (int): Left index.
        r (int): Right index.

    Returns:
        list: Insertion order of the keys.
    &#34;&#34;&#34;
    ordering: List[int] = []

    _recursive_ordering(m_roots, l, r, ordering)

    return ordering</code></pre>
</details>
</dd>
<dt id="fft_pd10.max_length_common_subsequence"><code class="name flex">
<span>def <span class="ident">max_length_common_subsequence</span></span>(<span>str_1:¬†str, str_2:¬†str) ‚Äë>¬†numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the array of partial common subsequence lengths.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>str_1</code></strong> :&ensp;<code>str</code></dt>
<dd>String 1.</dd>
<dt><strong><code>str_2</code></strong> :&ensp;<code>str</code></dt>
<dd>String 2.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Array of partial common subsequence lengths.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_length_common_subsequence(str_1: str, str_2: str) -&gt; np.ndarray:
    &#34;&#34;&#34;Calculates the array of partial common subsequence lengths.

    Args:
        str_1 (str): String 1.
        str_2 (str): String 2.

    Returns:
        np.ndarray: Array of partial common subsequence lengths.
    &#34;&#34;&#34;
    dp_matrix = np.zeros([len(str_2) + 1, len(str_1) + 1])

    for i in range(1, dp_matrix.shape[0]):
        for j in range(1, dp_matrix.shape[1]):
            if str_2[i - 1] == str_1[j - 1]:
                dp_matrix[i][j] = 1 + dp_matrix[i - 1][j - 1]
            else:
                dp_matrix[i][j] = max(dp_matrix[i][j - 1], dp_matrix[i - 1][j])

    return dp_matrix</code></pre>
</details>
</dd>
<dt id="fft_pd10.min_coin_number"><code class="name flex">
<span>def <span class="ident">min_coin_number</span></span>(<span>c:¬†int, l_coins:¬†List[int]) ‚Äë>¬†int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the minimum number of l_coins coins needed to give c change.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>int</code></dt>
<dd>Desired change.</dd>
<dt><strong><code>l_coins</code></strong> :&ensp;<code>list</code></dt>
<dd>Type of coins (values).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Minimum number of coins needed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def min_coin_number(c: int, l_coins: List[int]) -&gt; int:
    &#34;&#34;&#34;Calculates the minimum number of l_coins coins needed to give c change.

    Args:
        c (int): Desired change.
        l_coins (list): Type of coins (values).

    Returns:
        int: Minimum number of coins needed.
    &#34;&#34;&#34;
    coins = sorted(l_coins)
    ci = {i: coins[i] for i in range(len(coins))}
    dp_matrix = np.zeros([len(coins), c + 1])

    # TODO: ask if 1 always a coin
    # Initilize first row of matrix: n(1,c) = c
    for i in range(dp_matrix.shape[1]):
        dp_matrix[0][i] = i

    # Dynamic loop: n(i,c) = min{n(i-1,c), 1+n(i,c-vi)}
    for i in range(1, dp_matrix.shape[0]):
        for j in range(1, dp_matrix.shape[1]):
            no_i = dp_matrix[i-1][j]
            yes_i = np.inf

            if j &gt;= ci[i]:
                yes_i = 1 + dp_matrix[i][j - ci[i]]

            dp_matrix[i][j] = min(no_i, yes_i)

    return int(dp_matrix[-1][-1])</code></pre>
</details>
</dd>
<dt id="fft_pd10.mult_numbers_fft"><code class="name flex">
<span>def <span class="ident">mult_numbers_fft</span></span>(<span>num1:¬†int, num2:¬†int, fft_func:¬†Callable[[numpy.ndarray],¬†numpy.ndarray]¬†=¬†&lt;function fft&gt;) ‚Äë>¬†int</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplies integers using the FFT.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num1</code></strong> :&ensp;<code>int</code></dt>
<dd>The first integer.</dd>
<dt><strong><code>num2</code></strong> :&ensp;<code>int</code></dt>
<dd>The second integer.</dd>
<dt><strong><code>fft_func</code></strong> :&ensp;<code>function</code></dt>
<dd>The FFT function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The result of the multiplication.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mult_numbers_fft(
        num1: int, num2: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; int:
    &#34;&#34;&#34;Multiplies integers using the FFT.

    Args:
        num1 (int): The first integer.
        num2 (int): The second integer.
        fft_func (function): The FFT function.

    Returns:
        int: The result of the multiplication.
    &#34;&#34;&#34;
    pol1 = num_2_poli(num1)
    pol2 = num_2_poli(num2)

    result = mult_polynomials_fft(pol1, pol2, fft_func)

    return poli_2_num(result)</code></pre>
</details>
</dd>
<dt id="fft_pd10.mult_polynomials_fft"><code class="name flex">
<span>def <span class="ident">mult_polynomials_fft</span></span>(<span>l_pol_1:¬†List[int], l_pol_2:¬†List[int], fft_func:¬†Callable[[numpy.ndarray],¬†numpy.ndarray]¬†=¬†&lt;function fft&gt;) ‚Äë>¬†List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Multiplies two polynomials applying the FFT algorithm.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l_pol_1</code></strong> :&ensp;<code>list</code></dt>
<dd>List of coefficients of polynomial 1.</dd>
<dt><strong><code>l_pol_2</code></strong> :&ensp;<code>list</code></dt>
<dd>List of coefficients of polynomial 2.</dd>
<dt><strong><code>fft_func</code></strong> :&ensp;<code>function</code></dt>
<dd>Function of FFT.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Coefficients resulting of the multiplication.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mult_polynomials_fft(
        l_pol_1: List[int], l_pol_2: List[int],
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[int]:
    &#34;&#34;&#34;Multiplies two polynomials applying the FFT algorithm.

    Args:
        l_pol_1 (list): List of coefficients of polynomial 1.
        l_pol_2 (list): List of coefficients of polynomial 2.
        fft_func (function): Function of FFT.

    Returns:
        list: Coefficients resulting of the multiplication.
    &#34;&#34;&#34;
    length1 = _degree(l_pol_1)
    length2 = _degree(l_pol_2)

    pol_1 = _extend_table(np.array(l_pol_1), length1 + length2 + 1)
    pol_2 = _extend_table(np.array(l_pol_2), length1 + length2 + 1)

    # 1. Compute values of polynomials in special points (FFT)
    fft1 = fft_func(pol_1)
    fft2 = fft_func(pol_2)

    # 2. PQ(Xi) = P(Xi)Q(Xi)
    mult_points = np.array([fft1[i] * fft2[i] for i in range(len(pol_1))])

    # 3. Inverse FFT
    mult_coeff = invert_fft(np.array(mult_points), fft_func)

    return [round(x) for x in mult_coeff.real]</code></pre>
</details>
</dd>
<dt id="fft_pd10.num_2_poli"><code class="name flex">
<span>def <span class="ident">num_2_poli</span></span>(<span>num:¬†int, base:¬†int¬†=¬†10) ‚Äë>¬†List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a number into its polynomial representation in the base given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>Number to convert.</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>int</code></dt>
<dd>Base of the polynomial.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The polynomial.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_2_poli(num: int, base: int = 10) -&gt; List[int]:
    &#34;&#34;&#34;Converts a number into its polynomial representation in the base given.

    Args:
        num (int): Number to convert.
        base (int): Base of the polynomial.

    Returns:
        list: The polynomial.
    &#34;&#34;&#34;
    pol = []

    while num != 0:
        pol.append(num % base)
        num = num // base

    return pol</code></pre>
</details>
</dd>
<dt id="fft_pd10.optimal_change"><code class="name flex">
<span>def <span class="ident">optimal_change</span></span>(<span>c:¬†int, l_coins:¬†List[int]) ‚Äë>¬†Dict[int,¬†int]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dict with the coins needed to give change c.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>int</code></dt>
<dd>Desired change.</dd>
<dt><strong><code>l_coins</code></strong> :&ensp;<code>list</code></dt>
<dd>Coin values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Amount of coins needed of each type to return change c.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimal_change(c: int, l_coins: List[int]) -&gt; Dict[int, int]:
    &#34;&#34;&#34;Returns a dict with the coins needed to give change c.

    Args:
        c (int): Desired change.
        l_coins (list): Coin values.

    Returns:
        dict: Amount of coins needed of each type to return change c.
    &#34;&#34;&#34;
    n_coins = min_coin_number(c, l_coins)

    for x in combinations_with_replacement(l_coins, n_coins):
        if sum(x) == c:
            return {coin: x.count(coin) for coin in l_coins}

    return {}</code></pre>
</details>
</dd>
<dt id="fft_pd10.optimal_order"><code class="name flex">
<span>def <span class="ident">optimal_order</span></span>(<span>l_probs:¬†List[float]) ‚Äë>¬†Tuple[numpy.ndarray,¬†numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the optimal search binary tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l_probs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of probabilities of each key.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Matrix with optimal search costs.</dd>
<dt><code>np.ndarray</code></dt>
<dd>Subtree roots.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimal_order(l_probs: List[float]) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Calculates the optimal search binary tree.

    Args:
        l_probs (list): List of probabilities of each key.

    Returns:
        np.ndarray: Matrix with optimal search costs.
        np.ndarray: Subtree roots.
    &#34;&#34;&#34;
    N = len(l_probs)
    dp_matrix = np.zeros([N, N])
    roots = np.ones([N, N], dtype=int)*-1

    for L in range(N-1, -1, -1):
        for R in range(L, N):
            sum_pi = sum(l_probs[L:R+1])

            if L != R:
                min_cj = np.inf
                for j in range(L, R + 1):
                    c_L, c_R = 0, 0
                    if j - 1 &gt;= L:
                        c_L = dp_matrix[L][j-1]
                    if j + 1 &lt;= R:
                        c_R = dp_matrix[j+1][R]

                    if c_L + c_R &lt; min_cj:
                        min_cj = c_L + c_R
                        roots[L][R] = j
            else:
                min_cj = 0

            dp_matrix[L][R] = sum_pi + min_cj

    return dp_matrix, roots</code></pre>
</details>
</dd>
<dt id="fft_pd10.poli_2_num"><code class="name flex">
<span>def <span class="ident">poli_2_num</span></span>(<span>l_pol:¬†List[int], base:¬†int¬†=¬†10) ‚Äë>¬†int</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the polynomial with a certain base using Horner's rule.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l_pol</code></strong> :&ensp;<code>list</code></dt>
<dd>List of polynomial's coefficients.</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>int</code></dt>
<dd>Base of the polynomial.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Evaluation on the base.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poli_2_num(l_pol: List[int], base: int = 10) -&gt; int:
    &#34;&#34;&#34;Evaluates the polynomial with a certain base using Horner&#39;s rule.

    Args:
        l_pol (list): List of polynomial&#39;s coefficients.
        base (int): Base of the polynomial.

    Returns:
        int: Evaluation on the base.
    &#34;&#34;&#34;
    x = l_pol[-1]

    for i in range(len(l_pol) - 2, -1, -1):
        x = x * base + l_pol[i]

    return x</code></pre>
</details>
</dd>
<dt id="fft_pd10.rand_number"><code class="name flex">
<span>def <span class="ident">rand_number</span></span>(<span>num_digits:¬†int, base:¬†int¬†=¬†10) ‚Äë>¬†int</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a random int with num_digits figures in the base provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num_digits</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of digits.</dd>
<dt><strong><code>base</code></strong> :&ensp;<code>int</code></dt>
<dd>Base of the number.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The random number.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_number(num_digits: int, base: int = 10) -&gt; int:
    &#34;&#34;&#34;Generates a random int with num_digits figures in the base provided.

    Args:
        num_digits (int): Number of digits.
        base (int): Base of the number.

    Returns:
        int: The random number.
    &#34;&#34;&#34;
    return poli_2_num(rand_polynomial(num_digits, base), base)</code></pre>
</details>
</dd>
<dt id="fft_pd10.rand_polynomial"><code class="name flex">
<span>def <span class="ident">rand_polynomial</span></span>(<span>long:¬†int¬†=¬†1024, base:¬†int¬†=¬†10) ‚Äë>¬†List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a list with the coefficients of the polynomial with degree
length - 1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>long</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of the list. long - 1 identifies the degree of the</dd>
<dt>polynomial.</dt>
<dt><strong><code>base</code></strong> :&ensp;<code>int</code></dt>
<dd>Base of the coefficients.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List with the coefficients of the polynomial.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_polynomial(long: int = 2**10, base: int = 10) -&gt; List[int]:
    &#34;&#34;&#34;Generates a list with the coefficients of the polynomial with degree
    length - 1.

    Args:
        long (int): Length of the list. long - 1 identifies the degree of the
        polynomial.
        base (int): Base of the coefficients.

    Returns:
        list: List with the coefficients of the polynomial.
    &#34;&#34;&#34;
    return [random.randint(0, base - 1) for i in range(long - 1)] + \
        [random.randint(1, base - 1)]</code></pre>
</details>
</dd>
<dt id="fft_pd10.time_fft"><code class="name flex">
<span>def <span class="ident">time_fft</span></span>(<span>n_tables:¬†int, num_coefs_ini:¬†int, num_coefs_fin:¬†int, step:¬†int, fft_func:¬†Callable[[numpy.ndarray],¬†numpy.ndarray]¬†=¬†&lt;function fft&gt;) ‚Äë>¬†List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Times the execution of the FFT implementation provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_tables</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of tables to generate.</dd>
<dt><strong><code>num_coefs_ini</code></strong> :&ensp;<code>int</code></dt>
<dd>Initial number of coefficients.</dd>
<dt><strong><code>num_coefs_fin</code></strong> :&ensp;<code>int</code></dt>
<dd>Final number of coefficients.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>int</code></dt>
<dd>Step for the number of coefficients.</dd>
<dt><strong><code>fft_func</code></strong> :&ensp;<code>function</code></dt>
<dd>FFT implementation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List with the average times of the FFT.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_fft(
        n_tables: int, num_coefs_ini: int, num_coefs_fin: int, step: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[float]:
    &#34;&#34;&#34;Times the execution of the FFT implementation provided.

    Args:
        n_tables (int): Number of tables to generate.
        num_coefs_ini (int): Initial number of coefficients.
        num_coefs_fin (int): Final number of coefficients.
        step (int): Step for the number of coefficients.
        fft_func (function): FFT implementation.

    Returns:
        list: List with the average times of the FFT.
    &#34;&#34;&#34;
    results = []
    n_coeffs = num_coefs_ini
    while n_coeffs &lt;= num_coefs_fin:
        total_time = 0.0

        for i in range(n_tables):
            pol = rand_polynomial(n_coeffs)

            t = time.time()
            fft_func(np.array(pol))
            t = time.time() - t

            total_time += t

        results.append(total_time / n_tables)
        n_coeffs += step

    return results</code></pre>
</details>
</dd>
<dt id="fft_pd10.time_mult_numbers_fft"><code class="name flex">
<span>def <span class="ident">time_mult_numbers_fft</span></span>(<span>n_integers:¬†int, num_digits_ini:¬†int, num_digits_fin:¬†int, step:¬†int, fft_func:¬†Callable[[numpy.ndarray],¬†numpy.ndarray]¬†=¬†&lt;function fft&gt;) ‚Äë>¬†List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Times the execution of multiplication of numbers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_integers</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of integers generated.</dd>
<dt><strong><code>num_digits_ini</code></strong> :&ensp;<code>int</code></dt>
<dd>Initial number of digits.</dd>
<dt><strong><code>num_digits_fin</code></strong> :&ensp;<code>int</code></dt>
<dd>Final number of digits.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>int</code></dt>
<dd>Step for the number of digits.</dd>
<dt><strong><code>fft_func</code></strong> :&ensp;<code>function</code></dt>
<dd>FFT implementation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List with the average times of the multiplication.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_mult_numbers_fft(
        n_integers: int, num_digits_ini: int,
        num_digits_fin: int, step: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[float]:
    &#34;&#34;&#34;Times the execution of multiplication of numbers.

    Args:
        n_integers (int): Number of integers generated.
        num_digits_ini (int): Initial number of digits.
        num_digits_fin (int): Final number of digits.
        step (int): Step for the number of digits.
        fft_func (function): FFT implementation.

    Returns:
        list: List with the average times of the multiplication.
    &#34;&#34;&#34;
    results = []
    n_digits = num_digits_ini
    while n_digits &lt;= num_digits_fin:
        total_time = 0.0

        for i in range(n_integers):
            num1 = rand_number(n_digits)
            num2 = rand_number(n_digits)

            t = time.time()
            mult_numbers_fft(num1, num2, fft_func)
            t = time.time() - t

            total_time += t

        results.append(total_time / n_integers)
        n_digits += step

    return results</code></pre>
</details>
</dd>
<dt id="fft_pd10.time_mult_polynomials_fft"><code class="name flex">
<span>def <span class="ident">time_mult_polynomials_fft</span></span>(<span>n_pairs:¬†int, num_coefs_ini:¬†int, num_coefs_fin:¬†int, step:¬†int, fft_func:¬†Callable[[numpy.ndarray],¬†numpy.ndarray]¬†=¬†&lt;function fft&gt;) ‚Äë>¬†List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Times the execution of multiplication of polynomials.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_pairs</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pairs generated.</dd>
<dt><strong><code>num_coefs_ini</code></strong> :&ensp;<code>int</code></dt>
<dd>Initial number of coefficients.</dd>
<dt><strong><code>num_coefs_fin</code></strong> :&ensp;<code>int</code></dt>
<dd>Final number of coefficients.</dd>
<dt><strong><code>step</code></strong> :&ensp;<code>int</code></dt>
<dd>Step for the number of coefficients.</dd>
<dt><strong><code>fft_func</code></strong> :&ensp;<code>function</code></dt>
<dd>FFT implementation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List with the average times of the multiplication.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_mult_polynomials_fft(
        n_pairs: int, num_coefs_ini: int, num_coefs_fin: int, step: int,
        fft_func: Callable[[np.ndarray], np.ndarray] = fft) -&gt; List[float]:
    &#34;&#34;&#34;Times the execution of multiplication of polynomials.

    Args:
        n_pairs (int): Number of pairs generated.
        num_coefs_ini (int): Initial number of coefficients.
        num_coefs_fin (int): Final number of coefficients.
        step (int): Step for the number of coefficients.
        fft_func (function): FFT implementation.

    Returns:
        list: List with the average times of the multiplication.
    &#34;&#34;&#34;
    results = []
    n_coeffs = num_coefs_ini
    while n_coeffs &lt;= num_coefs_fin:
        total_time = 0.0

        for i in range(n_pairs):
            pol1 = rand_polynomial(n_coeffs)
            pol2 = rand_polynomial(n_coeffs)

            t = time.time()
            mult_polynomials_fft(pol1, pol2, fft_func)
            t = time.time() - t

            total_time += t

        results.append(total_time / n_pairs)
        n_coeffs += step

    return results</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fft_pd10.bellman_ford" href="#fft_pd10.bellman_ford">bellman_ford</a></code></li>
<li><code><a title="fft_pd10.fft" href="#fft_pd10.fft">fft</a></code></li>
<li><code><a title="fft_pd10.find_max_common_subsequence" href="#fft_pd10.find_max_common_subsequence">find_max_common_subsequence</a></code></li>
<li><code><a title="fft_pd10.invert_fft" href="#fft_pd10.invert_fft">invert_fft</a></code></li>
<li><code><a title="fft_pd10.list_opt_ordering_search_tree" href="#fft_pd10.list_opt_ordering_search_tree">list_opt_ordering_search_tree</a></code></li>
<li><code><a title="fft_pd10.max_length_common_subsequence" href="#fft_pd10.max_length_common_subsequence">max_length_common_subsequence</a></code></li>
<li><code><a title="fft_pd10.min_coin_number" href="#fft_pd10.min_coin_number">min_coin_number</a></code></li>
<li><code><a title="fft_pd10.mult_numbers_fft" href="#fft_pd10.mult_numbers_fft">mult_numbers_fft</a></code></li>
<li><code><a title="fft_pd10.mult_polynomials_fft" href="#fft_pd10.mult_polynomials_fft">mult_polynomials_fft</a></code></li>
<li><code><a title="fft_pd10.num_2_poli" href="#fft_pd10.num_2_poli">num_2_poli</a></code></li>
<li><code><a title="fft_pd10.optimal_change" href="#fft_pd10.optimal_change">optimal_change</a></code></li>
<li><code><a title="fft_pd10.optimal_order" href="#fft_pd10.optimal_order">optimal_order</a></code></li>
<li><code><a title="fft_pd10.poli_2_num" href="#fft_pd10.poli_2_num">poli_2_num</a></code></li>
<li><code><a title="fft_pd10.rand_number" href="#fft_pd10.rand_number">rand_number</a></code></li>
<li><code><a title="fft_pd10.rand_polynomial" href="#fft_pd10.rand_polynomial">rand_polynomial</a></code></li>
<li><code><a title="fft_pd10.time_fft" href="#fft_pd10.time_fft">time_fft</a></code></li>
<li><code><a title="fft_pd10.time_mult_numbers_fft" href="#fft_pd10.time_mult_numbers_fft">time_mult_numbers_fft</a></code></li>
<li><code><a title="fft_pd10.time_mult_polynomials_fft" href="#fft_pd10.time_mult_polynomials_fft">time_mult_polynomials_fft</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>